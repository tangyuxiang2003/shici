# 网络请求与组件封装规则

## 1. 网络请求规范

### 1.1 请求封装原则

#### 1.1.1 统一请求库
- 使用 `axios` 作为 HTTP 请求库
- 创建统一的请求实例，配置基础 URL、超时时间等
- 统一处理请求拦截和响应拦截

#### 1.1.2 请求配置规范
```javascript
// 请求实例配置示例
const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})
```

### 1.2 错误处理规范

#### 1.2.1 统一错误处理
- 在响应拦截器中统一处理网络错误
- 根据 HTTP 状态码进行不同处理
- 提供友好的错误提示信息

#### 1.2.2 错误码映射
```javascript
const errorMessages = {
  400: '请求参数错误',
  401: '未授权，请重新登录',
  403: '禁止访问',
  404: '资源不存在',
  500: '服务器内部错误',
  502: '网关错误',
  503: '服务不可用',
  504: '网关超时'
}
```

### 1.3 API 接口管理

#### 1.3.1 接口分类管理
- 按业务模块划分接口文件
- 统一导出接口函数
- 使用 TypeScript 类型定义（如适用）

#### 1.3.2 接口命名规范
```javascript
// 诗词相关接口
export const poemApi = {
  // 获取诗词列表
  getPoems: (params) => request.get('/poems', { params }),
  // 获取诗词详情
  getPoemDetail: (id) => request.get(`/poems/${id}`),
  // 添加诗词
  addPoem: (data) => request.post('/poems', data),
  // 更新诗词
  updatePoem: (id, data) => request.put(`/poems/${id}`, data),
  // 删除诗词
  deletePoem: (id) => request.delete(`/poems/${id}`)
}
```

### 1.4 请求状态管理

#### 1.4.1 加载状态管理
- 使用 `ref` 或 `reactive` 管理加载状态
- 在组件中显示加载指示器
- 防止重复请求

#### 1.4.2 示例实现
```javascript
const loading = ref(false)
const data = ref(null)

const fetchData = async () => {
  if (loading.value) return
  
  loading.value = true
  try {
    const response = await api.getData()
    data.value = response.data
  } catch (error) {
    console.error('请求失败:', error)
  } finally {
    loading.value = false
  }
}
```

## 2. 组件封装规范

### 2.1 组件设计原则

#### 2.1.1 单一职责原则
- 每个组件只负责一个明确的业务功能
- 避免组件过于复杂，保持可维护性
- 合理拆分大型组件为多个小组件

#### 2.1.2 可复用性原则
- 设计通用的基础组件
- 通过 props 实现组件定制化
- 提供合理的默认值和配置选项

### 2.2 组件文件结构

#### 2.2.1 标准文件结构
```
components/
├── base/           # 基础组件
│   ├── BaseButton.vue
│   ├── BaseInput.vue
│   └── BaseModal.vue
├── business/       # 业务组件
│   ├── PoemCard.vue
│   ├── AuthorCard.vue
│   └── SearchBox.vue
└── layout/         # 布局组件
    ├── Header.vue
    ├── Sidebar.vue
    └── Footer.vue
```

### 2.3 Props 设计规范

#### 2.3.1 Props 类型定义
```javascript
// 使用 Composition API
const props = defineProps({
  // 必填项
  title: {
    type: String,
    required: true
  },
  // 可选项，带默认值
  size: {
    type: String,
    default: 'medium',
    validator: (value) => ['small', 'medium', 'large'].includes(value)
  },
  // 复杂对象
  config: {
    type: Object,
    default: () => ({})
  },
  // 数组类型
  items: {
    type: Array,
    default: () => []
  }
})
```

#### 2.3.2 Props 命名规范
- 使用 camelCase 命名
- 避免使用 Vue 保留字
- 语义化命名，清晰表达用途

### 2.4 事件通信规范

#### 2.4.1 事件命名规范
```javascript
const emit = defineEmits([
  'update:modelValue',  // v-model 支持
  'submit',            // 表单提交
  'cancel',            // 取消操作
  'item-click',        // 项目点击
  'selection-change'   // 选择变化
])
```

#### 2.4.2 事件参数规范
- 事件参数应包含必要的信息
- 保持参数结构简单明了
- 提供完整的类型定义（如适用）

### 2.5 Slot 插槽设计

#### 2.5.1 命名插槽使用
```vue
<!-- 组件定义 -->
<template>
  <div class="card">
    <header v-if="$slots.header">
      <slot name="header" />
    </header>
    <main>
      <slot />
    </main>
    <footer v-if="$slots.footer">
      <slot name="footer" />
    </footer>
  </div>
</template>

<!-- 组件使用 -->
<Card>
  <template #header>
    <h3>卡片标题</h3>
  </template>
  
  卡片内容
  
  <template #footer>
    <button>操作按钮</button>
  </template>
</Card>
```

### 2.6 样式封装规范

#### 2.6.1 CSS 作用域
- 使用 `scoped` 属性避免样式污染
- 合理使用 CSS 变量实现主题定制
- 遵循 BEM 命名规范（可选）

#### 2.6.2 样式文件组织
```css
/* 基础样式 */
.poem-card {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 16px;
}

/* 状态样式 */
.poem-card--loading {
  opacity: 0.6;
}

.poem-card--selected {
  border-color: #007bff;
}

/* 元素样式 */
.poem-card__title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 8px;
}

.poem-card__content {
  color: #666;
  line-height: 1.5;
}
```

## 3. 业务组件示例

### 3.1 诗词卡片组件

#### 3.1.1 组件定义
```vue
<template>
  <div 
    :class="[
      'poem-card',
      { 'poem-card--favorite': isFavorite },
      { 'poem-card--loading': loading }
    ]"
    @click="handleClick"
  >
    <div class="poem-card__header">
      <h3 class="poem-card__title">{{ poem.title }}</h3>
      <el-button 
        :icon="isFavorite ? 'StarFilled' : 'Star'" 
        @click.stop="toggleFavorite"
        type="text"
      />
    </div>
    
    <div class="poem-card__author">{{ poem.author }} · {{ poem.dynasty }}</div>
    
    <div class="poem-card__content">
      {{ truncatedContent }}
    </div>
    
    <div class="poem-card__footer">
      <slot name="actions">
        <el-button size="small" @click.stop="viewDetail">查看详情</el-button>
      </slot>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  poem: {
    type: Object,
    required: true
  },
  isFavorite: {
    type: Boolean,
    default: false
  },
  loading: {
    type: Boolean,
    default: false
  },
  maxContentLength: {
    type: Number,
    default: 100
  }
})

const emit = defineEmits(['favorite-toggle', 'click', 'view-detail'])

const truncatedContent = computed(() => {
  if (props.poem.content.length <= props.maxContentLength) {
    return props.poem.content
  }
  return props.poem.content.slice(0, props.maxContentLength) + '...'
})

const toggleFavorite = () => {
  emit('favorite-toggle', props.poem)
}

const handleClick = () => {
  emit('click', props.poem)
}

const viewDetail = () => {
  emit('view-detail', props.poem)
}
</script>

<style scoped>
.poem-card {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.poem-card:hover {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.poem-card--favorite {
  border-color: #ffd04b;
}

.poem-card--loading {
  opacity: 0.6;
  pointer-events: none;
}

.poem-card__header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.poem-card__title {
  font-size: 18px;
  font-weight: bold;
  margin: 0;
  color: #333;
}

.poem-card__author {
  color: #666;
  font-size: 14px;
  margin-bottom: 12px;
}

.poem-card__content {
  color: #333;
  line-height: 1.6;
  margin-bottom: 16px;
}

.poem-card__footer {
  display: flex;
  justify-content: flex-end;
}
</style>
```

### 3.2 搜索组件

#### 3.2.1 组件定义
```vue
<template>
  <div class="search-box">
    <el-input
      v-model="keyword"
      placeholder="搜索诗词、诗人..."
      :prefix-icon="Search"
      clearable
      @input="handleInput"
      @clear="handleClear"
      @keyup.enter="handleSearch"
    >
      <template #append>
        <el-button :icon="Search" @click="handleSearch" />
      </template>
    </el-input>
    
    <!-- 搜索建议 -->
    <div v-if="showSuggestions && suggestions.length > 0" class="search-suggestions">
      <div 
        v-for="suggestion in suggestions" 
        :key="suggestion.id"
        class="suggestion-item"
        @click="selectSuggestion(suggestion)"
      >
        {{ suggestion.text }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, computed } from 'vue'
import { Search } from '@element-plus/icons-vue'
import { debounce } from 'lodash-es'

const props = defineProps({
  modelValue: {
    type: String,
    default: ''
  },
  delay: {
    type: Number,
    default: 300
  },
  showSuggestions: {
    type: Boolean,
    default: true
  }
})

const emit = defineEmits(['update:modelValue', 'search', 'suggestion-select'])

const keyword = ref(props.modelValue)
const suggestions = ref([])

// 防抖搜索
const debouncedSearch = debounce(async (value) => {
  if (!value.trim()) {
    suggestions.value = []
    return
  }
  
  try {
    // 调用搜索建议接口
    const response = await searchApi.getSuggestions(value)
    suggestions.value = response.data
  } catch (error) {
    console.error('获取搜索建议失败:', error)
    suggestions.value = []
  }
}, props.delay)

const handleInput = (value) => {
  emit('update:modelValue', value)
  debouncedSearch(value)
}

const handleClear = () => {
  suggestions.value = []
  emit('update:modelValue', '')
}

const handleSearch = () => {
  emit('search', keyword.value)
}

const selectSuggestion = (suggestion) => {
  keyword.value = suggestion.text
  emit('update:modelValue', suggestion.text)
  emit('suggestion-select', suggestion)
  suggestions.value = []
}
</script>

<style scoped>
.search-box {
  position: relative;
  width: 100%;
}

.search-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  z-index: 1000;
  max-height: 200px;
  overflow-y: auto;
}

.suggestion-item {
  padding: 8px 12px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.suggestion-item:hover {
  background-color: #f5f5f5;
}
</style>
```

## 4. 最佳实践总结

### 4.1 网络请求最佳实践
- 统一错误处理和加载状态管理
- 合理使用防抖和节流优化性能
- 实现请求缓存机制减少重复请求
- 使用环境变量管理 API 地址

### 4.2 组件封装最佳实践
- 遵循单一职责原则，保持组件简洁
- 提供充分的配置选项和插槽支持
- 使用 TypeScript 增强类型安全
- 编写详细的组件文档和使用示例

### 4.3 性能优化建议
- 合理使用 `v-if` 和 `v-show`
- 避免不必要的重新渲染
- 使用 `computed` 缓存计算结果
- 大型列表使用虚拟滚动

通过遵循这些规则，可以构建出可维护、可复用、高性能的 Vue.js 应用程序。